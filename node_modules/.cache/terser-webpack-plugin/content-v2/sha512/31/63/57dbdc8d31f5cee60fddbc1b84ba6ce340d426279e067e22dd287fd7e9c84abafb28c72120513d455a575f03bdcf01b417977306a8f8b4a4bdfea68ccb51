{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{371:function(t,n,e){\"use strict\";e.r(n);var s=e(42),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"react启程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react启程\"}},[t._v(\"#\")]),t._v(\" React启程\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_1-安装\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-安装\"}},[t._v(\"#\")]),t._v(\" 1.安装\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[t._v(\"环境要求：[Node >= 8.10 和 npm >= 5.6]\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"安装react脚手架：\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"npm install -g create-react-app\\n\")])])])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"创建react项目\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"npx create-react-app {项目名称} <js语言>\\nnpx create-react-app {项目名称} --typescript <ts语言>\\n\")])])]),e(\"p\",[t._v(\"tips:react项目目录,额,对比vue也属实有些拉跨。。。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"启动项目\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"npm start\\n\")])])])])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_2-react组件\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-react组件\"}},[t._v(\"#\")]),t._v(\" 2.React组件\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[e(\"p\",[t._v(\"类组件\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"import React,{Component} from 'react';\\n// q1 class Welcome extends Component | class Welcome extends React.Component | class Welcome extends Component 的区别?\\nclass Welcome extends Component {\\n  constructor(props){\\n  \\tsuper(props); //q2 关于这里会发现裂开,直接带删除线了?暂时也没弄明白.想在constructor使用this,必须要super继承.这里不明白先可以看ES6 Class.\\n  }\\n  render() {\\n    return <h1>Hello, {this.props.name}</h1>;\\n  }\\n}\\nexport default Welcome;\\n\")])])])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"函数式组件（stateless,又叫无状态组件）\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"import React from 'react';\\n/** 乍一看根本不需要引入import,其实非也,是因为在Babel转译我们的App.js的时候，会把JSX语法糖转换为React.createElement方法。\\n  * 仔细请阅读http://www.5idf.cn/jishu/59.html\\n  */\\n\\nfunction Welcome(props) {\\n  return <h1>Hello, {props.name}</h1>;\\n}\\nexport default Welcome;\\n\")])])]),e(\"p\",[t._v(\"tips:看到这是不是又觉得有些难以适应,毕竟.vue的三层分明\"),void 0,t._v(\" \"),e(\"script\")],2),e(\"style\"),e(\"p\")])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_3-props-和-event\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-props-和-event\"}},[t._v(\"#\")]),t._v(\" 3.props 和 event\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[e(\"p\",[t._v(\"父传子\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"// 若是在父组件应用了以上组件Welcome\\n// Father.js\\nfunction Father() {\\n  return (\\n  \\t<div class='Root'>\\n  \\t\\t<Son name='smith' />\\n  \\t</div>\\t\\n  );\\n}\\n// Son.js\\nfunction Son(props){\\n\\t<div>\\n\\t\\t<h1>Hola,{props.name}</h1>\\n\\t</div>\\t\\n}\\n\")])])])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"字传父\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"import React, { Component } from 'react';\\nimport Son from './Son';\\n\\nclass Father extends Component {\\n    constructor(...props) {\\n        super(...props);\\n        this.state = {\\n            son: ''\\n        }\\n    }\\n    render() {\\n        return (\\n            <div>\\n                <p>子传递过来的值{this.state.son}</p>\\n                <Son getVal={this.getVal} />\\n            </div>\\n        )\\n    }\\n\\n    getVal = (data) => {\\n        this.setState({\\n            son: data\\n        })\\n    }\\n}\\n\\n\\n\\nclass Son extends Component {\\n    constructor(...props) {\\n        super(...props)\\n        this.state = {\\n            sonState: '111'\\n        }\\n    }\\n    render() {\\n        return (\\n            <div>\\n                <p>{this.state.sonState}</p>\\n                <p onClick={this.toFather}>传父</p>\\n            </div>\\n        )\\n    }\\n\\n    toFather = () => {\\n        this.props.getVal(this.state.sonState)\\n    }\\n}\\n\")])])]),e(\"ul\",[e(\"li\",[t._v(\"react 中数据是单向流动的,所以不要在子组件直接去修改props的值.\")])])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"event\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[t._v(\"2.1 事件绑定\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v('class BindEvent extends Component {\\n    render() {\\n        return (\\n        \\t<div>\\n        \\t\\t<button className=\"container\" onClick={this.test.bind(this)}>方式一</button>\\n           \\t\\t<button onClick={this.test2}>方式二</button>\\n        \\t</div>\\t\\n        )\\n    }\\n\\n    test() {\\n    \\t// 普通函数声明 需要bind(this)\\n        console.log(this.props)\\n    }\\n\\n    test2 = () => {\\n    \\t// 箭头函数则DUCK不必\\n        console.log(this.props)\\n    }\\n}\\n')])])])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"2.2 事件传参\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v('class BindEvent extends Component {\\n    render() {\\n        return (\\n        \\t<div>\\n        \\t\\t<button className=\"container\" onClick={this.test(\"param1\"))}>错误的方式</button>\\n           \\t\\t<button onClick={()=>this.ok1(\"p1\",\"p2\")}>ES6的方式</button>\\n           \\t\\t<button onClick={function(){return this.ok2(p1,p2)}.bind(this)}>ES6的方式</button>\\n        \\t</div>\\t\\n        )\\n    }\\n    \\n    test(param){\\n    \\tconsole.log(,params) //未点击就执行了\\n    }\\n    \\n    ok1(p1,p2){\\n    \\n    }\\n    \\n    ok2(p1,p2){\\n        \\n    }\\n}\\n')])])])])])])]),t._v(\" \"),e(\"p\",[t._v(\"4State\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"class StateTest extends Component {\\n\\tconstructor(...props){\\n\\t\\tsuper(...props)\\n\\t\\t // 关于q1遗留的问题目前这么写可避免删除线.同时发现在constructor中随意console.log会执行两次,在render方法debugger后发现进入了两次断点.后来去网上查找原因,React在开发环境下会刻意执行两次渲染,以防止组件内有什么side effect引起 bug，提前预防。官方github也作出了声明.\\n\\t\\t//初始化state\\n\\t\\tthis.state = { desc:'我是默认值' }\\n\\t}\\n    render() {\\n        return (\\n        \\t<div>\\n        \\t\\t<span>{this.state.desc}</span>\\n           \\t\\t<button onClick={this.changeDesc}>修改state值</button>\\n        \\t</div>\\t\\n        )\\n    }\\n    changeDesc = () =>{\\n    \\tthis.setState({\\n    \\t\\tdesc:'改变成船新值'\\n    \\t})\\n    }\\n}\\n\")])])]),e(\"ol\",[e(\"li\",[t._v(\"注意的几点\\n\"),e(\"ul\",[e(\"li\",[t._v(\"state不要直接更改, this.stat.desc = 'xxx' ,这种方式改了页面也不会刷新的.请使用setState函数.\")]),t._v(\" \"),e(\"li\",[t._v(\"state的值可能是异步更新的.\")]),t._v(\" \"),e(\"li\",[t._v(\"state的更新会被合并.\")])])])])])}),[],!1,null,null,null);n.default=a.exports}}]);","extractedComments":[]}